# Table of Contents

* [Redis三大经典问题分析](#redis三大经典问题分析)
    * [简介](#简介)
    * [缓存穿透](#缓存穿透)
    * [缓存击穿](#缓存击穿)
    * [缓存雪崩](#缓存雪崩)
    * [总结](#总结)


# Redis三大经典问题分析

## 简介

标题虽说取名为Redis，但这三大问题是缓存都得碰到（当然目前主流的缓存就是Redis），这三大问题是啥呢？缓存穿透、缓存击穿和缓存雪崩。本文就对这三者基于Redis进行分析，不要再搞混了。


## 缓存穿透

**描述**：大量并发查询不存在的key（数据库中没有数据），导致这些查询全部透传到数据库，并且因为数据始终不存在，简直就是反复暴击。


**解决方案**

1. 当查询数据库未获取数据时，也存一个空值标记到当前key，这样下次的查询，根据这个空值key就能直接挡住不会透传到数据库。
    1. 实际使用中，只有使用string类型时比较适用，因为本身就是一个字符串，我存一个`null`字符串就行了，其他类型真没这么个简单办法能表示null。
    2. 可能造成缓存中存在了大量没有值的空key（难道这不该反思是安全管理出问题被恶意刷接口，或是确实业务有毛病呢，反倒是缓存救了系统一命不是）造成空间浪费。这一点其实看怎么看待，我倒是觉得做好监控报警更重要。
2. 使用额外的bitmap来做Bloom过滤判断key是够存在
    1. Bloom过滤是将一个key打散成多个hash（具体算法就不详解了），然后在bitmap对应这些hash位置标记为1，那么判断这个key存在必须是这数个hash值位置都是1才行（会有误伤，恰好两个key打散的hash都一致，但误判率只有万分之一）。Redis的bitmap支持2^32大小，对应到内存也就是512MB，可以放下2亿左右的数据，性能高，空间占用率及小。
    2. 使用上可以先正常去缓存取值，未取到准备去数据库时中间加这一道Bloom过滤。
3. 完全以缓存为准，使用延迟异步加载去更新缓存
    1. 假设一组数据以每分钟刷新数据的频率更新缓存，而用户查询时则完全以缓存为主，查不到就是没有。


## 缓存击穿

该问题不好好理解下，很容易和`缓存穿透`混淆，当然缓存击穿确实理解上就像是缓存穿透的子集。

**描述**：当某个key失效时，但还未来得及更新缓存，大量针对该key的并发请求压进来，都把压力压到了数据库。


**解决方案**

1. 缓存的更新加全局互斥锁，保证只有一个线程去更新缓存，其他线程等待拿到锁或者锁释放了就已经有数据了。
    1. 缺点就是若是操作延迟太长，严重影响了执行效率。
1. 完全以缓存为准，使用延迟异步加载去更新缓存


## 缓存雪崩

该问题又像是大量的`缓存击穿`的合体，雪崩了。

**描述**：某一时刻大量的key同时失效，但针对这些key的大量请求同时进来了。


**解决方案**

1. 首先保证系统能解决`缓存击穿`的问题，这就回顾上一条了。
2. 打散key的过期时间，使同一时刻大量key过期的概率降低。


## 总结

缓存的问题肯定还有很多，但是这三点是很基础也重要的，基本上要考虑使用缓存，这三个问题都没有考虑那将是极其不合理的。