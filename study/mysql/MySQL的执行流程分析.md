# Table of Contents

* [MySQL的执行流程分析](#mysql的执行流程分析)
  * [简介](#简介)
  * [Server层分析](#server层分析)
    * [连接器](#连接器)
* [查看当前值](#查看当前值)
* [查看全局配置值](#查看全局配置值)
* [设置当前值 重启后失效](#设置当前值-重启后失效)
* [设置全局值 重启后生效](#设置全局值-重启后生效)
      * [长连接和短连接](#长连接和短连接)
    * [查询缓存](#查询缓存)
    * [分析器（又称解析器）](#分析器（又称解析器）)
    * [优化器](#优化器)
    * [执行器](#执行器)
  * [查询流程分析（DQL）](#查询流程分析（dql）)
  * [更新流程分析（DML）](#更新流程分析（dml）)
    * [redo log](#redo-log)
    * [binlog](#binlog)
    * [redo log和binlog数据一致性如何保证？](#redo-log和binlog数据一致性如何保证？)



# MySQL的执行流程分析


## 简介

MySQL总体分为Server层和存储引擎层（Server层就是我们操作的MySQL，存储引擎层是真正负责数据交互的，可以理解为Server层是我们使用者和真正数据存储之间的中间件，顺便说一句，存储引擎是支持多个的，相当于外挂在MySQL上的，目前常见版本都是默认InnoDB的，因为它支持事务）。

Server层包含：连接器、查询缓存、分析器、优化器、执行器（交互存储引擎）等。

存储引擎层，插件式，支持InnoDB、MyISAM、Memory等（mysql命令后可通过`show engines`命令查看）。

## Server层分析

### 连接器

连接器是客户端访问MySQL的第一步，连接的命令如下：

```
mysql -h$ip -P$port -u$user -p
```

连接一旦建立，本次连接的用户权限就会固定，因为建立连接时读取权限就会固定，只要不重新连接，就算修改用户权限也不会生效。

连接建立后如若不使用，一段时间后会自动断开，该时间由参数`wait_timeout`控制，默认为8小时。若想查看，连接MySQL后，输入以下命令：

```
# 查看当前值
show variables like '%wait_timeout%';

# 查看全局配置值
show global variables like '%wait_timeout%';

# 设置当前值 重启后失效
set wait_timeout=30000;

# 设置全局值 重启后生效
set global wait_timeout=30000;
```

#### 长连接和短连接

长连接指连接成功后，客户端持续有请求，一直使用一个连接，短连接指每次执行完很少的几次查询就断开连接下次查询再重新建立一个。

建立连接是个复杂的过程，所以一般建议多使用长连接，但使用长连接有个问题，因为连接一直存在会一直消耗内存，所以如果连接存在时间过长，总会出现内存溢出的现象，针对该问题有如下思路可做考虑：

1. 定期断开长连接。按时间定期也可以做判断，执行过一个占内存大的查询；
2. 只限MySQL5.7以及以上版本，在执行完一个较大操作后，可以执行`mysql_reset_connection`初始化连接资源，该操作不需要重新连接和权限验证，仅仅是恢复到刚刚连接的状态。


### 查询缓存

若开启查询缓存，查询的语句和其结果会缓存在其中，如果后期同样的语句进来后就可以直接命中缓存把结果返回而不需要后面的步骤。

但是不建议使用MySQL自带的缓存，因为对表的更新会让该表对应的查询缓存全部失效，所以如果是频繁操作的表，开启查询缓存只是徒增性能损耗。操作频次低的表在当下其实也是建议业务自己采用专业的缓存机制（比如Redis）去缓存数据，减少DB的连接损耗（MySQL的连接采用的是BIO，所以连接资源非常宝贵，能尽量不操作MySQL就能解决的问题就不要去占用MySQL连接资源）。

虽然还有一种方式，可以配置按需使用查询缓存，这里也不多赘述，为啥，因为该方式对业务SQL具有污染性，不利于维护。

MySQL8版本其实官方就直接把查询缓存去除了。


### 分析器（又称解析器）

分析器就是检查SQL的，简单来说就是看看SQL的词法和语法有没有问题，避免带着最基本的错误还继续往后占用MySQL的连接。


### 优化器

到这里，MySQL已经确保了SQL没有问题，但是怎么执行还没有一个方案，这里就是去选择它认为的最优方案去执行，例如：选择哪个索引、有多个索引选择又选哪个索引最合适、多表join时又怎么执行更好。

举个例子：

```
select * from t1 join t2 using(id) where t1.c = 10 and t2.d = 20;
```

对于MySQL来说，这条语句它是有两个方案的：

1. 从t1取出c=10的记录的id并根据id关联t2，再判断t2的d是否为20；
2. 从t2取出d=20的记录的id并根据id关联t1，再判断t1的c是否为10；

这两个方案的效率最终肯定是不一样的，而优化器就是要决定使用哪个方案更佳。


### 执行器

这一步就是最后的关键一步了，走了那么多步的SQL语句，是骡子是马这一步都要去执行了。首先会进行权限认证，如果用户对表不具备相应权限权限（查询、插入、更新、删除...），会返回权限错误（补充一点，查询缓存命中也会做权限认证）。

通过权限认证，执行器就会打开表，根据表的引擎定义，使用这个引擎的接口。

举个例子：

```
select * from T where id = 10;
```

1. 调用InnoDB引擎的接口取该表第一行，判断id是否为10，不是则跳过，是则放入结果集；
2. 继续取下一行，判断，直到最后一行；
3. 执行器将所有满足条件的结果集返回给客户端。

若有索引，上述步骤不变，取行改为取满足条件的第一行，下一行。


## 查询流程分析（DQL）

![](http://106.15.233.185:8983/f0e2f945-aa20-41f9-9e55-85c0a8db78ed.png)


查询就不多说了，上面讲各个阶段也是以查询举的例子，回顾上述即可。


## 更新流程分析（DML）

比起查询，DML语句的执行流程肯定会复杂点，因为其涉及到对数据的变动还有事务，其实一直到引擎层位置，Server层的操作都差不多，所以更新这块我们更多的去关注引擎层的操作。

![](http://106.15.233.185:8983/9d88c14b-5b5b-4516-8f34-46d0d20553ef.jpg)


InnoDB引擎层步骤：

1. 写undo log（回滚、崩溃恢复的依据），储存回滚段指针和事务ID
2. 将记录所在页存到内存中
3. 写redo log
4. 写binlog
5. 提交事务
6. 刷redo log
7. 刷binlog


### redo log

如果每一次更新都直接写入磁盘，然后磁盘要找到数据，再更新，这个过程IO成本、查找成本都很高。所以MySQL就引入了先日志再写入的技术，专业的说叫WAL（Write-Ahead Logging）。

redo log就是这么一项技术，怎么个过程呢，每次更新时，InnoDB会把记录写到redo log，并更新内存，宏观上讲，这时候已经算是更新完成了。然后在适当的时间，InnoDB会将这个操作记录更新到磁盘里。

并且redo log的大小是一开始就定好了的，就像黑板一样，从头写到尾，满了，这时候再回到头擦掉重新从头写到尾。比如，redo log配置了一组四个文件，每个大小1GB，那总共就可以记录4GB的操作，以下图为例：

![](http://106.15.233.185:8983/1b48619d-30c5-4320-9b07-efa070c86757.png)

write pos是当前记录的位置，一边写一边向后移动，写到3号文件末尾就会回到0号文件的开始。checkpoint是当前要擦除的位置，也是向后移动并且循环的，擦除前要确保数据已经更新到数据文件。若是write pos追赶上了checkpoint那得等待checkpoint擦除出一定空间才会继续。

形象的说，这里面相当于有三个人分工，A不断把外界的东西一条条写上去，B则定期合适的时间把未处理的内容更新到数据文件，C则不断把黑板上已更新的数据擦除。

正因为redo log的功效，InnoDB就能保证数据库异常重启，之前提交的记录不会丢失，这个能力称作crash-safe。


### binlog

binlog区别于redo log，更像是一个备份日志，它会把执行的语句原封不动的写入日志。

为啥要同时用redo log和binlog，这就要从两者功能来叙述，redo log我们知道有个重要的能力就是crash-safe，这是只做归档的binlog所做不到的。同样的，归档也是很重要的，这又是redo log做不到的。

总结下redo log和binlog的不同点：

1. redo log是InnoDB引擎自带的，binlog则是Server层实现的，所有引擎共有；
2. redo log是物理日志，记录的是“在某个数据页上做了什么修改”，binlog是逻辑日志，记录的是这个语句的原始逻辑（简单理解就是语句本身）；
3. redo log是循环写的，空间固定，binlog是追加写的，所有日志不会被覆盖。


### redo log和binlog数据一致性如何保证？

这是个好问题，比如redo log写完库挂了，重启后redo log还在，但是binlog中是没有的。

这里就引出了**两阶段提交**的概念：

1. 写入redo log，处于prepare阶段；
2. 写入binlog；
3. 提交事务，把刚写完的redo log改为commit状态。


这样写完redo log挂了，这条记录不算数，写完binlog再挂了，重启两边的记录都有。
