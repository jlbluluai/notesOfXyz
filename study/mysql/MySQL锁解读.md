# Table of Contents

* [MySQL锁解读](#mysql锁解读)
    * [简介](#简介)
    * [全局锁](#全局锁)
    * [表级锁](#表级锁)
    * [行锁](#行锁)
        * [两阶段锁](#两阶段锁)
        * [死锁和死锁检测](#死锁和死锁检测)

# MySQL锁解读


## 简介

MySQL也是支持并发操作的，那就不可免俗的会面临并发安全性问题，那也就引出了锁。那么，在MySQL中锁又是怎样设计的呢？MySQL根据锁的数据范围大致可以分为全局锁、表级锁和行锁三种。


## 全局锁

顾名思义，全局锁会锁住整个数据库。可以用如下命令加锁解锁：

```
// 加锁
flush tables with read lock

// 解锁
unlock tables
```

一旦上锁，整个库只能读取数据，因此很适合在做**全库逻辑备份**时加（因为你不知道有没有疏忽的地方访问了该库并且还更新了数据）。

不过一般情况下也是用不到的，全局锁做个了解就行。


## 表级锁

MySQL中表级锁有两种，分别是表锁和元数据锁。

**表锁**的用法是：

```
// 锁单张表用法
lock table xx read/write

// 锁多张表用法
lock tables xx read/write, yy read/write
```

区分了加读锁还是写锁，若加了读锁，所有线程（包括自己）后续也不能修改，但加的是写锁的话，自己后续还是可以修改的。


再来看看另一种表级锁-**元数据锁（MDL）**，MDL不需要显示的使用，在访问一张表的时候会自动加上，目的是为了隔离DML和DDL操作之间的干扰性。详细来说，对表进行DML操作时会加MDL读锁，对表进行DDL操作时会加MDL写锁（读读共享，读写互斥，写写互斥）。


## 行锁

比起前两个锁，行锁才是我们日常碰到的最多（以InnoDB引擎为例，某些引擎都没行锁的当我没说），也是最容易出问题（恶贯满盈的死锁）。

顾名思义，行锁锁的就是表里面每一行数据，进一步缩小了锁的粒度，带来了性能的提升，同时也带来了更多的安全性问题。

### 两阶段锁

在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立即释放，而是要等到事务结束时才释放。

举个例子：

<table>
    <tr>
        <td>事务A</td>
        <td>事务B</td>
    </tr>
    <tr>
        <td >
        begin
        <br/>
        update t set a=1 where id=1;
        <br/>
        update t set a=1 where id=2;
        </td>
        <td></td>
    </tr>
    <tr>
        <td></td>
        <td>
        update t set a=2 where id=1;
        </td>
    </tr>
    <tr>
        <td>commit;</td>
        <td></td>
    </tr>
</table>

该例子中事务B执行update会是什么现象呢？事务B的update会阻塞等到事务A commit 之后才能继续执行。

分析来看，事务A执行了两条update语句，也就持有了id 1和2两条记录的行锁，既然事务B在事务A执行完后还是无法获取id 1的锁，说明只有在commit的时候行锁才被释放。


那么知道了这一点有什么用呢？我举个例子就好理解了。

假设现在有一个简单的在线商城，顾客购买流程的细则大概有以下几点：

1. 生成交易订单；
2. 顾客账户余额扣减；
3. 商家账户余额增加；
4. 生成交易日志。

显然这个流程得用事务包含，我们假设代码的执行顺序就按上面罗列的一样，顾客A下单后执行第三步，这时候顾客B也下单并执行完了第二步，按照两阶段锁的定义，顾客B在执行到第三步时会等待顾客A完整执行完（商家的账户被顾客A抢先占有，并且事务未提交）。

回顾这个过程没什么问题，但有没有优化的点呢？我们看执行步骤，第三步锁住后开始等待却要完整的等待完3、4两步，其实是浪费的，因为第四步的生成交易日志显然不会冲突，而且流程是个完整的事务，我们把顺序调整为如下就能尽可能少的减少等待时间：

1. 生成交易订单；
2. 顾客账户余额扣减；
3. 生成交易日志；
4. 商家账户余额增加。

这样就算并发用户再多，前三步都不会阻塞。


### 死锁和死锁检测

死锁是个很让人头痛的玩意，为了高并发引入了细粒度的行锁必然也带来了它。

像上面举得复杂的事务流程自己玩基本上也不会遇到死锁，但是这玩意就是人写的代码，稍微不加留意就会出现差错。我们继续基于这个在线商城举例子。

回顾上面说的简单的下单流程：

1. 生成交易订单；
2. 顾客账户余额扣减；
3. 生成交易日志；
4. 商家账户余额增加。

这里再加入一个新的退单流程：

1. 商家账户余额减少；
2. 顾客账户余额扣减；
3. 生成交易日志。

我们假设顾客A已经开始下单流程，这时候商家针对顾客A上一单进行退单操作，发生了什么呢？假设退单走完第二步，下单走完第三步，这时候退单流程拿不到顾客A的账户锁，下单流程也拿不到商家的账户锁，互相在那等待，这就引发死锁了（举个例子，别当真，当然现实是更残酷的）。

出现死锁后有两种策略：

1. 设置超时等待时间，超过就当失败回滚事务（通过`innodb_lock_wait_timeout`，默认是50s）；
2. 开启死锁检测（设置`innodb_deadlock_detect`为on即可），开启后自动检测，一旦发现死锁，主动回滚某一个事务。