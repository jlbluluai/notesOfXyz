# Table of Contents

* [IO模型解读](#io模型解读)
    * [简介](#简介)
    * [同步阻塞模型-BIO](#同步阻塞模型-bio)
    * [同步非阻塞模型-NIO](#同步非阻塞模型-nio)
    * [IO多路复用](#io多路复用)
    * [信号驱动IO](#信号驱动io)
    * [异步IO](#异步io)
    * [总结](#总结)


# IO模型解读

## 简介

谈IO前，我们先清楚两个概念：用户态和内核态。用户态简单理解就是应用程序所在处，内核态简单理解就是负责从源头读取（磁盘、网络）和向目标写入（磁盘、网络）。所以IO的简单流程可以如下表示：

```
用户态 <-> 内核态 <-> 磁盘、网络
```

然后我们再来区分IO，分两个维度，分别是同步、异步和阻塞、非阻塞，怎么理解呢？

- 同步、异步指的是通信模式
    - 应用程序->内核要拿到一个结果才算结束即为同步
    - 应用程序->内核仅是一个类似通知不需要结果即为异步
- 阻塞、非阻塞指的是线程处理模式
    - 应用程序线程一直等待内核数据准备好即为阻塞
    - 应用程序线程调用内核后发现数据未准备好就去干别的了即为非阻塞

这就有了3类IO模型--同步阻塞（BIO）、同步非阻塞（NIO）、异步非阻塞（AIO）。

紧接着又能引出5种IO模型：

![](http://img.yelizi.top/ed5f5296-6910-471b-8fe0-ebe887b3a7dd.jpg$xyz)

值得注意的是，异步I/O模型其实目前技术还不成熟，知道这个概念就行，别把其他非阻塞的同步模型和异步搞混（换句话说目前常见的IO模型都是同步的，区别只是阻塞、非阻塞）。


## 同步阻塞模型-BIO

![](http://img.yelizi.top/559561bb-e166-459b-802c-e578eb7f20a3.jpg$xyz)

这是最常见的IO模型，比如Java中的Socket编程就是基于同步阻塞。

优点：

1. 理解简单
2. 代码简单

缺点：

1. 并发量高和内存消耗低几乎是两个极点
2. 就算不顾及内存消耗，并发量也有限，管理大量线程也有一定的性能浪费

## 同步非阻塞模型-NIO

![](http://img.yelizi.top/22cc778e-69f0-44ca-8c2f-14ab26aa9163.jpg$xyz)

观察BIO模型不难发现，内核一开始数据并没有准备好，也就是应用线程不仅等了波数据从内核复制到用户空间，还等了波内核准备好数据。

**补充**：可能有人还是很难理解内核的工作，我用常见的网络调用介绍下，数据准备就是内核等待网络的那头的数据传输过来，数据复制就是内核把准备好的数据复制到用户态给应用程序用。

而NIO的思路就是优化数据准备这一块，若是数据没有准备好，直接返回没有准备好的结果给应用程序，而应用程序则是利用一个主动轮询多次去询问内核是否准备好数据，这一块就是非阻塞的。

而等到某一次询问，内核已经准备好数据，则开始进行真正的复制，这一块还是阻塞。

优点：

1. 并发量提高
2. 内存消耗降低（一定量的线程已经能服务很多的连接量）


## IO多路复用


![](http://img.yelizi.top/31aa2ff3-ebd1-406c-a16c-a615647d95ae.jpg$xyz)


![](http://img.yelizi.top/a790946f-a99c-4a2d-9e6e-556678c11715.jpg$xyz)

IO多路复用学Redis时可能经常挂在嘴边，似乎这就是Redis这么快的核心原因。

其实我们的Java本身的NIO也是IO多路复用的模型，所以其实不必翻看Redis源码也能获取基于IO多路复用的最佳实践。

其基本理解就是，通过单个线程同时监控多个套接字（socket），通过select或poll轮询所负责的所有套接字，当某个套接字有数据到达了，就通知用户进程。并且select调用是由内核来负责本来是用户进程该做的轮询操作。


所以IO多路复用理解起来也挺微妙的，对于处理的用户线程，在真正处理前是确实是非阻塞的，但对于调用select的线程（一般称为Reactor线程）来说，其确实又是阻塞等待select结果的。所以理解到这里就不要再简简单单的说IO多路复用是阻塞还是非阻塞的了。

[关于Java中NIO的简单实战-待定]()

[关于select的简单理解-待定]()


## 信号驱动IO

这块平时涉及的不多，简单了解下。

![](http://img.yelizi.top/89b20902-7b01-4af6-ba6f-fbfd6b7e5c19.jpg$xyz)

IO多路复用通过调用select将轮询交给了内核，而信号驱动IO则是对这个轮询的另一种优化，取消轮询。

用户进程一开始像内核发送一个信号，告诉内核我要什么，内核数据准备好了，就会主动发送一个信号给用户进程，用户进程这时候再去调用获取数据。


## 异步IO

![](http://img.yelizi.top/db999aec-9cb8-460a-a003-2bd5dd284afc.jpg$xyz)

简单理解下就是连信号驱动IO模型的发送信号都省了，用户进程告诉内核我要什么就去干别的了，内核准备好后主动就把数据送过去给用户进程。



## 总结

本篇简单的介绍了下IO模型，通篇涉及的同步、异步和阻塞、非阻塞概念也仅限于理解IO模型，至于其它地方涉及这些概念自行理解，不过本质上是一样的。

要理解IO模型的核心就是要先认识用户空间和内核空间，不然基本上很难理解一些过程和术语。