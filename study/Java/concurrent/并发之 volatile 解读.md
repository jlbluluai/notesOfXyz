# Table of Contents

* [并发之 volatile 解读](#并发之-volatile-解读)
    * [可见性](#可见性)
    * [线程处理共享变量的浅解读](#线程处理共享变量的浅解读)
    * [引出 volatile](#引出-volatile)
    * [能试验出不可见的 Demo](#能试验出不可见的-demo)
    * [引出内存屏障](#引出内存屏障)
    * [总结](#总结)


# 并发之 volatile 解读

## 可见性

在讨论 `volatile` 之前，我们先讨论下可见性问题，这就是 `volatile` 要去解决的问题。

什么是可见性？就是针对共享变量（多个线程都可以访问到的变量）的操作对互相都是可见的。那么对应的不可见那就出现可见性问题了，在Java中 `volatile` 关键字就是是辅助共享变量对互相必然（可以体会下这个必然）可见。


## 线程处理共享变量的浅解读

要具体去引出 `volatile` 如何解决可见性问题，那必然要先清楚，线程究竟是如何去处理这个共享变量的。

在此之前，务必先清楚[Java线程与CPU的关系](https://blog.csdn.net/wutongyuWxc/article/details/78732287)，不清楚这这点很大程度上会把自己的思维限制在Java层面而无法去理解一些怪异现象（不仅限于本篇关于`volatile`，包括所有的并发问题）。

基于上面对CPU已经有了基本认知后，继续往下看，我们假设一个CPU有4个物理核心，每个核心只支持一个线程工作（对于单核多线程这里不做假设，这种硬件上的技术徒增理解难度）。也就是说，我们假设的CPU同时支持4个线程的计算服务。

我们继续假设，Java里创建了6个线程工作，那么这里的线程又和CPU是怎么联系的呢，下面我画了一张图（不是很准确，但基本能理解）：

![](http://img.yelizi.top/d123a400-5040-4805-87eb-89b4d31f46f8.jpg$xyz)

我们大概可以得出以下几点结论来辅佐认知（包括导链的内容）：

1. 系统涉及的CPU个数不能严谨说是物理的CPU个数（比如i5-8400这么一块CPU只是物理存在的一块U），而是工作的CPU核心数（可以是一块物理U的多核，也可以是多块物理U的多核）；
2. 系统能支持的理论上的并行数取决于第一条所说的核心数，我们假设单核只有单线程（实际上硬件技术不止如此），那么四个核心同时也只能调度4个线程单位处理。
3. CPU为了减少访问内存所需的平均时间，其每个工作线程还会维护高速缓存区过度（也就是图中的线程-缓存，实际CPU的缓存比这里描述的还要复杂，但含义上就是这样，不影响我们理解）；
4. Java线程只是作为Java进程（JVM）调度一个线程单位，和CPU的工作线程没有直接关系，通过时间片轮转，Java线程的会被调度并发的去争取CPU资源（也就是去抢CPU工作线程）然后计算；
5. 基于第三条，不可见体现在哪，比如4个核心都针对同一变量count进行加1操作，核心1~4都会将count在各自的工作线程缓存区缓存一份，互相是不可见的。


## 引出 volatile


至此，我们已经对可见性问题有了基本的认知：

> CPU的多核多线程化才致使了可见性的并发安全性问题，单核单线程的机器无需考虑。

最终反映到应用层面的java身上，也就可以理解为不同线程对于共享变量处理的不可见，怎么理解呢：

1. java线程1~4四个线程均被安排对同一count加1，4个线程分别被调度去四个核心计算，四个核心的缓存区读取的初始值都是0，并各自缓存了一份；
2. 假设java线程1的加1指令被分配的核心率先计算完反馈给内存，也就是这时对于共享变量count本身值已经变为1；
3. 但此时java线程2~4根据各自的缓存区均只知道count为0，也就是内存变动的新值对它们不可见；
4. 最后的结果就是4个线程分别执行了加1，期待结果是4，但结果为1   。实际上假设4个核心的count缓存一直不失效，这个开多线程去加1就成了笑话，就算加1操作100次，最终内存中的count值也只会是不多不少的100。


其实要如何解决可见性问题已经很明确了，就是如何即时让每个核心线程缓存区的值失效。

在Java中，volatile关键字就是扮演这个角色，它的使用也很简单（就是在正常的变量声明再加一个关键字volatile）：

```
private volatile int count;
```


## 能试验出不可见的 Demo

上面的所有假设其实都是建立在最佳时机下，其实系统的运行千变万化，这种在Bebug试验就毫无意义了，以下我们举出实际的人可感知的不可见案例：


```java
public class Visibility {

    // 共享变量count 初始化为0
    public int count = 0;

    public static void main(String[] args) {
        Visibility m = new Visibility();

        // 启动两个线程 线程1休息3s后循环累加10次 线程直接循环判断count是否为0，不为0则输出count变化被感知
        Thread t1 = new Thread(() -> {
            try {
                Thread.sleep(3000);
            } catch (InterruptedException ignore) {
            }
            for (int i = 0; i < 10; i++) {
                m.count++;
            }
        });
        Thread t2 = new Thread(() -> {
            while (m.count == 0) {
            }
            System.out.println("count加被感知了");
        });

        t1.start();
        t2.start();

        // 休息5s 保证线程1已经累加完
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // 输出当前count值 不出意外是10
        System.out.println(m.count);

        // 避免主线程结束
        try {
            Thread.sleep(100 * 1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```


这个案例每一步做什么直接看注释即可，我们运行它会咋样呢？不出意外的话5s后会输出一个数字10，再过100s后程序结束，几乎无可能看到`count加被感知了`这句话，count在t1的变动是不是对t2不可见了。

后面在主线程的输出也是为了佐证主内存中的count已经变成了10，但对于t2的while循环，似乎每一次都在重新取得count值，但实际while循环却一直进行也就是t2始终取得的count为0。

其实这个案例是因为强加了一些条件让不可见暴露出来或者说能人为debug到，但不代表可见性问题只停留在理论无需重视。可见性问题是非常严重的并发安全性问题，这不是八股文！！！机器的运算能力是人的不知道多少倍，你通过写一些常规代码debug测不出不可见不代表发布线上机器高速运转时不会发生。


## 引出内存屏障

那么我们的Demo代码中的count用`volatile`修饰一下会咋样?

1. 第3s输出`count加被感知了`
2. 第5s输出`10`
3. 第105s程序终止

到了这里，我们应该已经有能力问出：`volatile`是如何让处理t2的CPU核心的缓存中的count值即时失效的？

典型答案就是：**内存屏障**

我们先不去解释这个**内存屏障**，遇事不决先看看编译后的字节码长啥样子：

```
public volatile int count;
descriptor: I
flags: (0x0041) ACC_PUBLIC, ACC_VOLATILE
```

对于count变量多了一个`ACC_VOLATILE`修饰，其余都没看出啥变化，那说明处理就在虚拟机本身，不过多扯淡，这里最终是用了C++的`volatile`关键字的功能，感兴趣的可以[了解一下](https://blog.csdn.net/qq_19648191/article/details/89353335)。


到这里，我们再回过头解释下**内存屏障**：

> 内存屏障（英语：Memory barrier），也称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，它使得 CPU 或编译器在对内存进行操作的时候, 严格按照一定的顺序来执行, 也就是说在内存屏障之前的指令和之后的指令不会由于系统优化等原因而导致乱序。 --维基百科


基于上面的认知并且导链内容也基本了解，我们再达成以下几点共识：

1. Java层面所有的代码最终到底层都将是一条条给CPU执行的汇编指令；
2. Java通过关键字`volatile`实现内存屏障，反映到底层就是在对`volatile`变量的操作时会被施加屏障指令（汇编指令）；
    - 屏障指令可分为两种：读屏障和写屏障。在指令前插入读屏障，会强制从主内存加载数据（CPU缓存失效），在指令后插入写屏障，会强制把缓存的值刷回主内存；
3. 基于简单的屏障指令的认知，其实我们已经能理解如何解决可见性，但对于JMM来说不够准确，如有需要可以继续去[了解一下](https://juejin.cn/post/6876395693854949389#comment)；
4. 不光是可见性问题，内存屏障同样能解决有序性问题，不知道你们发现了没有；



## 总结

`volatile`是Java用来解决可见性问题的关键字，解决可见性问题的根源在于内存屏障，`volatile`关键字解决可见性问题就在于对底层汇编指令施加了内存屏障。

所以，只要涉及对共享变量并发计算，请先确保变量修饰了`volatile`关键字，保证最基本的可见性。

也请记住保证了可见性并不是说就没有了其他安全性问题，还有原子性问题排队等着呢。或者你可以这么理解，没保障可见性别扯并发，这是基本但不是最终。


对于`volatile`的解读涉及的知识面实在过于广大（JVM、C++、硬件...），本文说实话大部分说的只是基于我目前的浅薄理解（写错在所难免），写最后这一句话不是为了告诉别人，警醒自己本文尚不完善，未来实力若更加精进，记得重修！！！
