# Table of Contents

* [Java内存模型解读](#java内存模型解读)
  * [简介](#简介)
  * [JVM内存结构和Java运行时数据区](#jvm内存结构和java运行时数据区)
    * [Java运行时数据区](#java运行时数据区)
      * [堆](#堆)
      * [方法区](#方法区)
      * [程序计数器](#程序计数器)
      * [虚拟机栈](#虚拟机栈)
      * [本地方法栈](#本地方法栈)
    * [JVM内存结构](#jvm内存结构)
      * [栈内存结构](#栈内存结构)
      * [堆内存结构和非堆内存结构](#堆内存结构和非堆内存结构)
  * [JMM与线程规范](#jmm与线程规范)



# Java内存模型解读

## 简介

JVM为什么称为虚拟机，是因为它是一个完整的计算机模型，所以自然就有对应的内存模型，这个模型就称为**Java内存模型（Java Memory Model）**，简写就是**JMM**。

JMM规定了JVM应该如何使用计算机内存。广义来说，JMM可以分为两部分：

- JVM内存结构
- JMM与线程规范

## JVM内存结构和Java运行时数据区

JVM内存结构有人会直接说成Java运行时数据区，两者确实有涵盖关系，但也不能说是一个东西，或者说他们是就一个东西进行了不同维度的分析，我是这么理解的。所以若是面试时被问及，可以就两方面去回答，或者就只谈论一方面，不要混搭着自己都搞不清楚。

### Java运行时数据区

![img](https://raw.githubusercontent.com/jlbluluai/xyz-notes/master/img/core/jvm004.png)

#### 堆

- 堆是JVM管理的最大的一块内存，是用来存放对象实例和数组的。同时堆也是垃圾回收器的主要管理区域。堆的大小是可以指定的，通过-Xmx和-Xms来控制。内存不够时会抛出“OutOfMemmory”。


#### 方法区

- 别被这个名称绕晕了，这只是个概念，不同的虚拟机可能会有不同实现。记住在Java8官方虚拟机（Hotspot） 中就是元空间（Metaspace）,或者其实也可以把方法区笼统理解为内存结构中的非堆。
- 如果看做就是元空间（Metaspace），那么其中存放的就是类的方法信息以及类的常量池（运行时常量池）信息。


#### 程序计数器

- 程序计数器相当于JVM所执行的字节码（jvm指令）的“行号指示器”，通过程序计数器的“值”找到吓一跳需要执行的字节码指令。因为线程私有，每个线程都有自己的程序计数器，此内存区域是唯一一个没有规定 “OutOfMemoryError”的区域。
- 说白了就是配合字节码工作的东西，方法的执行都是线程私有的，那么这玩意也就是线程私有的。


#### 虚拟机栈

- 虚拟机栈是一个“栈结构”的内存区域（先进后出）。里面存的是一个个“栈帧”。每个栈帧存储了局部变量表，操作数栈，动态连接，方法返回地址等。
- 该区域有两种异常：当请求的“栈深度”大于JVM虚拟机所允许的深度时，抛出“StackOverFlowError”。当内存不够时，抛出“OutOfMemmory”。


#### 本地方法栈

- 本地方法栈类似于虚拟机栈，不同处在于，虚拟机栈为虚拟机运行的Java方法服务，本地方法栈为虚拟机使用的native方法服务。


### JVM内存结构

前面分析了运行时数据区域，这里再从内存结构的角度去看。

- 栈
- 堆
- 非堆（方法区）

#### 栈内存结构

其对应的就是运行时数据的虚拟机栈。

![](http://img.yelizi.top/2d88cd95-8154-402d-860b-bee1b9e201f1.jpg$xyz)

JVM中，每个正在运行的线程都会有自己线程栈。线程栈包含了当前正在执行的方法链/调用链上的所有方法的状态信息。每个方法占一个空间称为`栈帧`。

每个方法的局部变量都存在于自己帧内的局部变量表（局部变量是线程安全的原因）。

每启动一个线程，JVM就会在栈空间分配对应的线程栈，默认1MB（-Xss1m可以自定义）。

如果调用的是JNI方法，还会独立分配单独的本地方法栈，对应的就是运行时数据区的本地方法栈。



#### 堆内存结构和非堆内存结构

![](http://img.yelizi.top/2f667ca7-b5e5-46ca-a790-fcc0b0efd9d3.jpg$xyz)

堆内存又称`共享堆`，只要有对象的引用地址，任何线程都可以访问堆中的对象。

堆内存基于分代思想，又将堆内存划分为年轻代和老年代，具体的可以参照GC相关的解读。

非堆本质是还是Heap，但是不归GC管理，Java8中有3部分：

- Metaspace（元空间），里面就是方法区，所以上面说的方法区在Java8中可以等同于元空间。
- CSS（Compressed Class Space），存放class信息，和Metaspace有重叠（方法信息也是class信息）。
- Code Cache，存放JIT编译器编译后的本地机器代码。


## JMM与线程规范

JMM规范明确定义了不同线程之间，通过哪些方式，在什么时候可以看见其他线程保存到共享变量中的值；以及在必要时，如何对共享变量的访问进行同步。这样的好处是屏蔽各种硬件平台和操作系统之间的内存访问差异，实现了Java并发程序真正的跨平台。

**JMM规范内容**

> 给定一个程序和该程序的一串执行轨迹，内存模型描述了该执行轨迹是否是该程序的一次合法执行。对于Java，内存模型检查执行轨迹中的每次读操作，然后根据特定规则，检验该读操作观察到的写是否合法。<br>
内存模型描述了某个程序的可能行为。JVM实现可以自由地生成想要的代码，只 要该程序所有最终执行产生的结果能通过内存模型进行预测。这为大量的代码转换提供了充分的自由，包括动作（action）的重排序以及非必要的同步移除。<br>
内存模型的一个高级、非正式的表述"显示其是一组规则，规定了一个线程的写操 作何时会对另一个线程可见"。通俗地说，读操作 r 通常能看到任何写操作 w 写入 的值，意味着 w 不是在 r 之后发生，且 w 看起来没有被另一个写操作 w' 覆盖掉 （从 r 的角度看）。

详细可以参阅[JSR133中文版.pdf](http://ifeve.com/wp-content/uploads/2014/03/JSR133%E4%B8%AD%E6%96%87%E7%89%88.pdf)
