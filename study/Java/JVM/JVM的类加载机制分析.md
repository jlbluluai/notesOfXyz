# Table of Contents

* [JVM的类加载机制分析](#jvm的类加载机制分析)
    * [概述](#概述)
    * [类的生命周期](#类的生命周期)
        * [加载](#加载)
        * [验证](#验证)
        * [准备](#准备)
        * [解析](#解析)
        * [初始化](#初始化)
        * [使用](#使用)
        * [卸载](#卸载)
    * [类加载器](#类加载器)
        * [双亲委派模型](#双亲委派模型)
    * [自定义类加载器实战](#自定义类加载器实战)
    * [实战后分析](#实战后分析)
    * [总结](#总结)


# JVM的类加载机制分析

## 概述

类加载机制算是JVM层面最重要的东西了，我们的类在JVM使用都是过的这一关。那么这个JVM的层面的东西为什么要去了解呢。


## 类的生命周期

先来一张经典图：

![](http://img.yelizi.top/5566057e-20e4-4b88-875b-b0cea5b95324.png$xyz)

类是啥，最终打包执行的时候就是一个个.class文件，所以就记住一个类的生命周期就是围绕一个.class文件从磁盘加载进内存开始再到从内存卸载谢幕为止。

.class文件加载进内存应该干什么，当然需要先验证文件是否合法以及做一些解析工作，对应到就是图中的连接大模块。

然后呢，我们就认为这个类就准备完毕了，那干啥，当然是初始化类，初始化后干啥当然就是使用啦。

这么去想这个流程，是不是清晰很多，死记硬背没有什么意义。

下面就每一个小步骤大概干了什么罗列下：

### 加载

上面我说一个类的生命周期围绕一个.class文件从磁盘加载进内存开始并不准确。

准确的说这一步是从某个源头获取class内容流（你可以是标准的.class文件，也可以网络传输，甚至就是字符串等等），本质上只要能获取二进制字节流都可。

该步骤完成下面三步：

1. 通过类的全限定类名获取类的二进制字节流（源头不限，动态加载类也就是基于这个特性）
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个java.lang.Class对象，也就是我通常说的类对象在这里就已经生成了


### 验证

验证就是保证我们的类在当前JVM是可被执行的，比如生成class的Java版本是否可被接受（Java11编译的class大概率在老古董Java5的JVM中是不会被验证通过，打个比方而已，并没有亲自验证过）。


### 准备

该阶段仅仅就是针对类中static修饰的成员变量进行初始化赋值，基本类型就是对应的零值，引用类型则直接就是null。

### 解析

该阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。

### 初始化

经过上面的阶段后，类就算是在内存中暂时安家了，但类并没有初始化，怎么理解呢，确实现阶段内存有java.lang.Class对象，但其静态成员依旧是准备阶段定的零值，所以有了这一步骤，就是初始化类对象。

所以该阶段不要和类的实例化去混淆，直到该步骤，一直都还在围绕类本身做工作。

那怎么触发初始化呢，这个不用担心，你能想到所有你去用这个类的方式只要其还未初始化，都会进行到这一步。

该步骤主要干两个事情：

1. static变量若是赋定了初始值，则要将该初始值替换掉零值
2. 静态代码块中内容在该步骤执行

**注意**：这里涉及所有的步骤只和类本身挂钩，千万不要和实例化混淆

### 使用

字面理解即可，无论你是用类的静态变量，还是调静态方法，还是实例化类，都属于使用范畴。


### 卸载

有始必有终，一旦程序终止（无论什么形式的），都将触发卸载。

从这里的定义也可以看出，一个类在一次程序的运行周期中只会被加载一次。


## 类加载器

提类加载器又得提到上述的加载阶段了，加载阶段的第一步就是通过类的全限定类名获取定义此类的二进制字节流，这就要涉及到类加载器这个概念了。

Java默认提供了三种类加载器（知道就好，没必要背，下面会提到的自定义加载器好好理解下倒是实实在在的东西）：

- 启动类加载器（Bootstrap ClassLoader）：负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类。
- 扩展类加载器（Extension ClassLoader）：负责加载 JAVA_HOME\lib\ext 目录中的，或通过java.ext.dirs系统变量指定路径中的类库。
- 应用程序类加载器(Application ClassLoader)：负责加载用户路径（classpath）上的类库。
  当然，有需求的话还可以自定义类加载器。这么多加载器，他们是个怎么样的联系呢？

用一张经典图描述这个关系：

![](http://img.yelizi.top/ab4abf7b-6ab4-47b1-a9f5-01f65325ca47.png$xyz)

看到这张图千万不要误会这是一个继承关系，他们只是层级关系（其实类比阶级这个名词会显得更好理解，下面我也会提到）。

图中还有提及自定义加载器，这就是留给使用者的扩展点了，在Java中，要自定义就继承`java.lang.ClassLoader`即可，具体实践转到[自定义类加载器实战](#自定义类加载器实战)。

那么说了这么多难懂的东西，这个类加载器还有这么多层次，到底类加载器是如何工作的呢，这里就不得不引出双亲委派模型了。


### 双亲委派模型

说实在我一直对这个模型的翻译是不感冒的，让初学者简直一脸懵逼，双亲难道有两个？还有前面说了这不是继承关系，那为啥又涉及到父母的概念？

所以我主张先知道它叫啥就行，至于怎么理解继续向下看。

我们调用任何类加载器，首先会让上层的类加载器去加载，若加载不了才会自己去加载，比如我们现在调用了自定义类加载器，也只有自定义类加载器能够加载，但这里会先依次委派直到顶端--启动类加载器，然后一层层下来依次尝试加载不成，最后自定义类加载器才会自己加载。

我用一个比方来描述一下，上面我提及这个层级关系更像阶级，我做一个角色假设：启动类加载器（国王）、扩展类加载器（贵族）、应用类加载器（士族）、自定义类加载器（平民）、加载的类（宝物），那么怎么理解呢，假设平民获取一个宝物，他不能先占为己有，必须一层层向上上报到国王，国王看了眼，我不要，那就是继续往下，直到上面的阶级都不要，平民才能自己享有宝物。

这有什么好处呢？比如我们要加载Object类，如果用了双亲委托模型，总是会由启动类加载器去加载，但是若没有用的话，用各个类加载器自行加载，此时若是编写了一个Object类，那么系统中就会有多个Object类，这就会一片混乱。

## 自定义类加载器实战

用于动态载入的测试类（请注意案例我将包路径也附上了，这很重要）：

```java
package com.xyz.study.common.classload;

public class Hello {

    public void sayHello() {
        System.out.println("hello");
    }

}
```

自定义的测试类加载器：

```java
public class HelloClassLoader extends ClassLoader {

    private static Map<String, byte[]> dynamicClassMap = new HashMap<>();


    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        byte[] bytes = dynamicClassMap.get(name);
        if (bytes == null) {
            throw new RuntimeException("未找到类信息");
        }
        return defineClass(name, bytes, 0, bytes.length);
    }


    public static void main(String[] args) throws Exception {
        // 模拟载入类信息
        byte[] bytes = FileUtils.localFileToByte(new File("上面测试类编译后的class文件路径"));
        dynamicClassMap.put("com.xyz.study.common.classload.Hello", bytes);

        // 模拟使用
        Class<?> hello = new HelloClassLoader().findClass("com.xyz.study.common.classload.Hello");
        Object o = hello.newInstance();
        Method method = hello.getMethod("sayHello");
        method.invoke(o);
    }
}
```

为了直观，放出我用来测试用到的文件（Hello.class为Hello类编译生成的class文件）：

![](http://img.yelizi.top/75dad076-b35d-499a-8340-dc39867d987d.jpg$xyz)

为了测试结果的没有疑惑性，实际的Hello类在生成class文件后已经完全完全被注释掉。

我们运行HelloClassLoader#main，控制面板就会输出`hello`。


## 实战后分析

趁着实战的热度还没过，我们就其中几点可以分析下：

1. 理论上我们只需要能够获取class内容的字节数组，无论来源是哪，都能通过全限定类名+字节数组动态加载（实战中就是通过读取class文件）；
2. 动态加载的类去执行必然四通过反射机制；
3. 实现动态类加载去实现某些功能就是通过的自定义类加载器。


## 总结

JVM的类加载机制本身可以算是八股文，好像你懂了不懂对一般开发而言也就是那么回事。

不过由类加载机制引出的动态类加载在实践中还是有很大的作用的，而用一个东西却不了解其逻辑，那是很可怕并且不专业的。所以从这个实践出发去看待类加载机制，一来显得没那么抽象，二来也实实在在又掌握一项装逼本领。