# Table of Contents

* [GC解读-具体实现](#gc解读-具体实现)
    * [常见的GC的具体实现](#常见的gc的具体实现)
        * [Serial GC（串行GC）](#serial-gc（串行gc）)
* [提一嘴，启动参数中关于true/false的配置一般都是通过+/-表示](#提一嘴，启动参数中关于truefalse的配置一般都是通过-表示)
    * [Parallel GC（并行GC）](#parallel-gc（并行gc）)
    * [CMS GC（Concurrent Mark Sweep GC，并发标记清除GC）](#cms-gc（concurrent-mark-sweep-gc，并发标记清除gc）)
        * [第一阶段：Initial Mark（初始标记）](#第一阶段：initial-mark（初始标记）)
        * [第二阶段：Concurrent Mark（并发标记）](#第二阶段：concurrent-mark（并发标记）)
        * [第三阶段：Concurrent Preclean（并发预清理）](#第三阶段：concurrent-preclean（并发预清理）)
        * [第四阶段：Concurrent Abortable Preclean（可取消的并发预清理）](#第四阶段：concurrent-abortable-preclean（可取消的并发预清理）)
        * [第五阶段：Final Remark（最终标记）](#第五阶段：final-remark（最终标记）)
        * [第六阶段：Concurrent Sweep（并发清除）](#第六阶段：concurrent-sweep（并发清除）)
        * [第七阶段：Concurrent Reset（并发重置）](#第七阶段：concurrent-reset（并发重置）)
    * [G1 GC（Garbage-First GC）](#g1-gc（garbage-first-gc）)
    * [前者开启GC 后者设置你期望的STW的最长毫秒数，G1会尽量满足](#前者开启gc-后者设置你期望的stw的最长毫秒数，g1会尽量满足)
        * [年轻代模式转移暂停](#年轻代模式转移暂停)
        * [并发标记](#并发标记)
            * [第一阶段：Initial Mark（初始标记）](#第一阶段：initial-mark（初始标记）-1)
            * [第二阶段：Root Region Scan（Root区扫描）](#第二阶段：root-region-scan（root区扫描）)
            * [第三阶段：Concurrent Mark（并发标记）](#第三阶段：concurrent-mark（并发标记）)
            * [第四阶段：Remark（再次标记）](#第四阶段：remark（再次标记）)
            * [第五阶段：Cleanup（清理）](#第五阶段：cleanup（清理）)
        * [混合模式转移暂停](#混合模式转移暂停)
    * [基于常见GC的选用分析](#基于常见gc的选用分析)
    * [拓展的GC实现](#拓展的gc实现)


# GC解读-具体实现

## 常见的GC的具体实现

基本上常见的GC实现都是基于分代假设的理念。

### Serial GC（串行GC）

Serial GC对年轻代使用`mark-copy（标记-复制）`算法，对老年代使用`mark-sweep-compact（标记-清除-整理）`算法。两者都是单线程运行，并且都会触发STW，停止所有的应用线程（故得名Serial）。

显然，该GC实现不能充分利用多核CPU的优势，所以JVM默认使用的也不是该GC（以JDK8为例）。

若要启用该GC，启动参数指定如下即可（年轻代和老年代同时生效）：

```
# 提一嘴，启动参数中关于true/false的配置一般都是通过+/-表示
-XX:+UseSerialGC
```

综合分析，该GC只适合小内存（几百M）的单核服务器使用。


### Parallel GC（并行GC）

Parallel GC对年轻代使用`mark-copy（标记-复制）`算法，对老年代使用`mark-sweep-compact（标记-清除-整理）`算法。两者都会触发STW，但在执行标记、复制和整理时会使用多个线程（故得名Parallel）。

若要启用该GC，启动参数指定如下三组其一即可（年轻代和老年代同时生效）：

```
-XX:+UseParallelGC

-XX:+UseParallelOldGC

-XX:+UseParallelGC -XX:+UseParallelOldGC
```

默认启动的多个线程就是CPU的核心数，可以通过`-XX:ParallelGCThreads=xxx`来指定启用的线程数。

该方式能有效的利用多核CPU的性能，大大提升了JVM的吞吐量，所以该GC的引入，才标志着JVM的生产运行的可能性（Parallel GC也是JDK8的默认的选用GC）。


### CMS GC（Concurrent Mark Sweep GC，并发标记清除GC）

回顾Parallel GC，虽然有效的提高了吞吐量，但是它的年轻代和老年代的GC还是要STW的，年轻代一般还好，但是老年代触发的GC（一般我们也可以称为full GC或是major GC）很容易出现长时间的卡顿。

那么有办法还能在这之上优化吗？CMS GC就旨在对老年代GC进行优化，既然STW影响了延迟，换个思路，能否让老年代的GC不需要STW或者不需要那么全面的STW（这样就能相当程度减少对应用线程的影响）。

CMS GC对年轻代使用`mark-copy（标记-复制）`算法，对老年代采用`concurrent mark-sweep（并发 标记-清除）`算法。

可以通过如下指令指定使用CMS GC：

```
-XX:+UseConcMarkSweepGC
```


那么这个`并发 标记-清除`如何避免老年代GC的长时间卡顿，总结以下两点：

1. 取消了整理，也就是一定程度上允许碎片空间的堆积（空间的浪费）来换区时间上的效率；
2. 在原本的`mark-sweep`阶段中细分的大部分小阶段允许GC线程和应用线程同时工作（减少全程STW带来的应用时间暂停）。


那么有人要问了，不进行整理，那实在是存不下了会咋办？当然也不是没有这种机制，不然CMS GC就可以直接宣布死亡了。当老年代实在是没有任何能分配下一对象的空间时（不做整理的后果），那么这时会进行一次真正意义上的full GC（全线暂停，STW），但很可惜的是，该full GC是以Serial模式进行的，对性能的影响还是有一定的。

所以使用CMS要注意两点：

1. 内存不能小
    - 若是JVM的内存不大（某种程度上说就是取决物理机本身内存），那也是不建议使用CMS的。因为CMS的老年代GC（指的正常情况CGC）是没有整理这一步骤的，所以内存小的情况，再加上碎片空间浪费，很快就将不可使用，大内存一定程度是能规避的（或者说是达到极限的时间线被放长了）这个风险的。
2. 做好参数配置：
    1. `-XX:CMSInitiatingOccupancyFraction=N`（设定内存占用率达到多少开始CGC（并发GC，CMS里可以理解为是老年代的major GC），调小这样CGC开始的早，old不容易满，减低FGC的可能性）
       `-XX:+CMSScavengeBeforeRemark`（设定触发CGC的阈值固定，也就是前面那个值，不设定，默认会自动调整，也就是只配前面那个等于没用）
    2. `-XX:+UseCMSCompactAtFullCollection`（设定Full GC时作整理，默认就是开启的） `-XX:CMSFullGCBeforeCompaction=N`（设定每N次Full GC后才进行整理，默认是0，也就是每次Full GC都会整理。在内存碎片化和Full GC时长间作取舍，可以适当调整）


**注意**：若是CPU核数不多，也是不建议使用CMS GC的（当然一般情况内存都小了，CPU也不会大了，不然这物理机不就是个畸形儿，emm）。并发并不是说完全就能让应用线程跑的很顺畅，默认CMS的GC线程是CPU核心数的**1/4**，也就是说当核数不多的时候，同时用有限的CPU资源既要处理GC又要处理应用，争抢资源将非常激烈（CPU不断切换时间片也将是不可小视的性能损耗）。


那么这个CMS的老年代GC算法（CGC）到底是怎么去优化的？如何保证应用线程和GC线程同时运作却不会发生混乱？

CMS GC将老年代的GC划分成好几个小阶段，正是这样的拆解，让并发成为了可能性。

#### 第一阶段：Initial Mark（初始标记）

![](http://img.yelizi.top/baf33e5a-f2fd-41b8-84ed-044f67af2d41.jpg$xyz)

该阶段会进行一次全线暂停（STW），标记的对象包括两种：

1. 从GC roots出发可达的老年代对象；
2. 被年轻代中存活对象可达的老年代对象。

**引出一个小知识点**：为啥CGC不需要管年轻代呢？因为发生CGC的前提是，一次YGC（说minor GC也行）后，发生对象晋升分配至老年代，然后老年代的内存占用率达到设定的阈值（默认是80%？）。也就是CGC可以认为是紧接着YGC的，并且第一阶段-初始标记是STW的（相当于两个STW紧挨着，那么中间可以认为没有发生什么），所以再去回收年轻代也没有什么效果。

#### 第二阶段：Concurrent Mark（并发标记）

![](http://img.yelizi.top/c15dd943-baec-4f7a-b940-18defe088386.jpg$xyz)

该阶段CMS GC遍历老年代，从第一阶段标记的对象的根对象算起，标记所有存活对象。由于该阶段是和应用线程并发进行的，若在标记中对象的引用关系发生变化，所以并非所有老年代存活的对象都在此阶段被标记。

如图所示，`当前处理对象`的一个可达链由于应用线程活动就断开了，即这部分的对象关系发生了变化。


#### 第三阶段：Concurrent Preclean（并发预清理）

该阶段也是与应用线程并发进行的。

因为前一阶段（并发标记）可能会有一些引用关系发生了改变，而如果在并发标记过程中引用关系发生了改变，JVM会通过 **Card（卡片）** 的方式将发生改变的区域标记为“脏区”，这就是所谓的`卡片标记（Card Marking）`。

![](http://img.yelizi.top/67478bed-d57d-4579-94d6-e351b2f9a261.jpg$xyz)


在该阶段，这些“脏区”的对象会被统计出来，他们所引用的对象也会被标记。此阶段后，用于标记的card也会被清空。

![](http://img.yelizi.top/ab6d47a7-1581-4ad6-882c-a4da958a573b.jpg$xyz)


#### 第四阶段：Concurrent Abortable Preclean（可取消的并发预清理）

该阶段也不停止应用线程。本阶段尝试在 STW 的 Final Remark阶段 之前尽可能地多做一些工作。

本阶段的 具体时间取决于多种因素，因为它循环做同样的事情，直到满足某个退出条件( 如迭代次数，有用工作量， 消耗的系统时间等等)。


#### 第五阶段：Final Remark（最终标记）

该阶段是一轮CGC的第二次STW（也是最后一次）。

本阶段的目标是完成老年代中所有存活对象的标记，因为之前预清理阶段是并发的，有可能GC线程跟不上应用的修改速度，所以本阶段需要STW来处理各种复杂的情况。

通常CMS会尝试再年轻代尽可能空的情况下执行Final Remark，以免连续触发多次STW（前面并发的步骤年轻代是正常工作的）。

#### 第六阶段：Concurrent Sweep（并发清除）

该阶段无需STW，删除不再使用的对象，并回收他们占用的内存。

![](http://img.yelizi.top/e0f02696-bf52-4b3d-990c-5ab2779eb82a.jpg$xyz)


#### 第七阶段：Concurrent Reset（并发重置）

该阶段重置CMS算法相关的内部数据，为下一次GC做准备。



### G1 GC（Garbage-First GC）

首先明确一点，G1 GC也是并发的GC，可以看做是CMS GC的升级版。G1 GC最主要的设计目标就是将STW的停顿时间和分布变成可预期且可配置的。例如，可以指定在任意XX毫秒时间范围内，STW停顿不得超过YY毫秒。G1 GC会尽力达成这个目标（大概率，并不是完全）。

为了达成可预期的停顿时间的指标，G1 GC区别传统的分代有了一些独特的实现，堆不再硬性的划分为固定的年轻代和老年代，而是划分为多个小块堆区域（通常是2048个）。每个小块一会是Eden区，一会可能又是Survivor区或Old区。然后逻辑上把所有Eden小块和Survivor合并称为年轻代，所有的Old小块合并称为老年代（所以G1 GC依旧是基于分代假设的）。

![](http://img.yelizi.top/c00a44a0-962d-4b87-ae37-fb28587027bb.jpg$xyz)

那这样划分有什么好处呢？这样划分后，GC不必每次都要收集整个堆空间，而是可以以增量的方式进行处理（每个小块区是独立的，可以每次只回收部分小块区）。每次GC暂停都会回收所有年轻代，但一般只包含部分老年代的小块区。

![](http://img.yelizi.top/f28dfbe7-b064-45ae-9d0c-19aa372a3d58.jpg$xyz)

当然，这部分老年代的小块区也不是随意选择的，G1会在并发阶段
估算每个小块区存活对象的总数，并遵循一个原则：垃圾最多的小块会被优先回收（为啥名字叫Garbage-First，也就是体现在这里）。

若要启用该GC，启动参数指定如下（顺带提一下，从JDK9开始，G1 GC就是默认的GC策略了）：

```
## 前者开启GC 后者设置你期望的STW的最长毫秒数，G1会尽量满足
-XX:+UseG1GC -XX:MaxGCPauseMillis=50
```

[G1 GC常用启用参数手册]()

为啥说G1 GC是CMS GC的升级版呢？因为G1 GC也是并发的，并且其解决了碎片空间的问题。但是分析它的GC还是比较好玩的，下面分几块分析。

**注意**：G1 GC和CMS一样作为并发的GC，也会面临一个问题，内存真正满额不够时会引发串行化的Full GC，当然由于G1是会整理内存碎片的，真正达到满额的概率是远低于CMS GC的，具体出现问题还得结合其他指标一起分析。

#### 年轻代模式转移暂停

年轻代模式转移暂停看起来高大上，其实就是G1的年轻代GC。

G1 GC会通过前面一段时间的运行来不断调整回收策略和行为，来比较稳定地控制暂停时间。应用刚启动时，G1还没有收集到足够的信息，这时候处于初始的 `fully-young` 模式。当年轻代空间满了后，应用线程会被暂停，年轻代小块中的存活对象被拷贝至存活区（若还没有存活区，就选择任意一部分空闲的小块作为存活区）。这里的转移其实就是拷贝，所以其实逻辑上来看，G1 GC年轻代GC也是和前面讲的GC一样的 `mark-copy` 。


#### 并发标记

当老年代使用内存占比达到45%（`-XX:+InitiatingHeapOccupancyPercent`可自定义值），G1将开始启动老年代的回收，在真正回收老年前有一个完整的并发标记阶段（其目的是为了是否进行老年代回收做准备，但不一定会进行）。

G1的并发标记通过 **起始快照** 的方式，在标记阶段开始时记下所有的存活对象。即使在标记的同时又有一些对象变成了垃圾。

当堆内存总体使用比例达到一定数值，就会触发并发标记，这个数值默认是 **45%** ,通过 `-XX:InitiatingHeapOccupancyPercent=45` 可以自定义。和CMS一样，G1的并发标记也是由多个小阶段组成，其中部分还是会触发STW。

##### 第一阶段：Initial Mark（初始标记）

该阶段标记所有从GC roots直接可达的对象。在CMS中需要进行一次STW，但G1里通常在转移暂停的同时就处理了这些事情，所以它的开销很小（你可以认为进行了STW，但是基本等于没有时长）。


##### 第二阶段：Root Region Scan（Root区扫描）

该阶段标记所有从 **根区域** 可达的存活对象。**根区域** 包括：非空的区域以及标记过程中不得不收集的区域。

因为在并发标记的过程中应用线程也在工作（就有可能造成转移暂停），所以此阶段必须在下一次转移暂停前完成（该阶段的标记是并发的，而并发中迁移对象会非常麻烦）。如果必须启动转移暂停，那就会先暂停该阶段的工作先去转移暂停。


##### 第三阶段：Concurrent Mark（并发标记）

此阶段和CMS的并发标记阶段非常类似：只遍历对象图，并在一个特殊的位图中标记能访问到的对象。为了保证标记开始时的快照准确性，所有应用线程并发对对象图执行引用更新，G1要求放弃前面阶段为了标记目的而引用的过时引用。


##### 第四阶段：Remark（再次标记）

该阶段有点类似CMS的最终标记阶段，会进行一次STW以完成标记过程。

该阶段主要是标记所有在并发标记（即上一阶段）开始时未被标记的存活对象。该阶段也会执行一些额外的清理，如引用处理或者类卸载。


##### 第五阶段：Cleanup（清理）

该阶段是整个大的并发标记阶段的最后一个阶段，为即将到来的转移阶段做准备，统计小块中所有存活的对象，并将小块排序（提升GC的效率）。此阶段也为下一次标记执行必须的整理工作：维护并发标记的内部状态。

该阶段的清理在哪呢？所有不包含存活对象的小块将会被回收，此阶段也需要一个短暂的STW。


#### 混合模式转移暂停

并发标记结束后，G1有可能会开启mixed GC（即混合模式转移暂停），mixed GC会取代young GC（即年轻代模式转移暂停），mixed GC会回收年轻代以及一部分老年代。当满足可回收占比小于5%（`-XX:G1HeapWastePercent`可自定义数值），mixed GC就会退回为young GC（也就是结束对老年代的回收）。

为啥说是有可能开启？并发标记中有个清理阶段，若有不包含存活对象的小块会直接回收掉，那很可能回收完后，就达不到回收老年代的标准了（前面提及的45%），那也没必要启用mixed gc了。



## 基于常见GC的选用分析

| 名称 | 工作模式 | 算法（新生代/老年代） | 优势 | 适合场景 |
| --- | --- | --- | --- | --- |
| Serial GC | 串行 | mark-copy/mark-sweep-compact | 响应速度优先 | 单核CPU的小内存服务器 |
| Parallel GC | 并行 | mark-copy/mark-sweep-compact | 吞吐量优先 | 多核CPU的正常服务器 |
| CMS GC | 并发 | mark-copy/mark-sweep | 响应速度优先 | 大内存有响应速度要求的服务器 |
| G1 GC | 并发 | mark-copy/mark-sweep-compact | 响应速度优先 | CMS的升级版 |


## 拓展的GC实现

...