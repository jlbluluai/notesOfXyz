# Table of Contents

* [GC解读-宽泛概念](#gc解读-宽泛概念)
    * [简介](#简介)
    * [举个例子代入GC](#举个例子代入gc)
    * [浅析GC的工作模式](#浅析gc的工作模式)
        * [标记可达对象](#标记可达对象)
        * [删除不可达对象](#删除不可达对象)
            * [复制（标记-复制）](#复制（标记-复制）)
            * [清除](#清除)
            * [整理](#整理)
    * [引出分代假设](#引出分代假设)
    * [GC管理的堆内存划分](#gc管理的堆内存划分)
        * [年轻代（Young区）](#年轻代（young区）)
            * [新生代（Eden区）](#新生代（eden区）)
            * [存活区（Survivor区）](#存活区（survivor区）)
            * [YGC理解](#ygc理解)
        * [老年代（Old区）](#老年代（old区）)


# GC解读-宽泛概念

## 简介

GC全称Garbage Collection，直译就是垃圾收集，也可以说成是垃圾回收。这么看有点迷糊，贴近现实的来说，可以笼统说成就是管理堆内存的一种（或者说是一组）算法机制，实现对对象的统一维护管理，里面可能会涉及到诸如对象的晋升、对象的回收等等。


## 举个例子代入GC

`云服务器`这个东西现在大家基本都不陌生了，这玩意为啥能火呢，其中基本也是核心的一点就是按传统的搭建自己的线下服务器，成本太大，这对很多的小公司和个人来说简直就是不可接受的。

而推出`云服务器`就完美的解决了这个痛点，例如你只需要2核4G的配置，我就提供这样的服务给你，这样大公司有钱自己搭服务器玩，小公司也能买云服务器玩，而且如果在线用户多了，要加机器再付费立马就能有，或者公司规模不行，要削减开支，停几台服务器，那也是一样的。

GC就是类似这样的一个统一管理对象等等资源的地方，学习过C++的可能都知道，所有创建的资源都得自己主动回收（就和每个公司自己搭建服务器一样），而Java可能初学者都不知道还有回收这回事，代码里没有啊，这就好比我用的云服务器，我自己公司肯定是看不到服务器的。

当然，既然资源不需要主动管理了，那这个GC到底怎么工作的，出了问题又怎么办肯定是老手要关心的问题了。那就要娓娓道来了。


## 浅析GC的工作模式

总结GC来说，GC无非就干两件大事情（其他无非是围绕这个展开的）：

1. 查出所有存活的对象；
2. 删掉非存活的对象。


### 标记可达对象

这个查出所有存活的对象在GC里面就是`标记`阶段，标记什么？标记出从GC roots出发所有可达的对象，那么这个roots是啥呢？

![](http://img.yelizi.top/247d5255-3047-4f05-90dc-34a035c28aa8.jpg$xyz)

GC roots（GC根元素）包括如下：

- 当前正在执行的方法里的局部变量和入参；
- 活动的线程
- 内存中所有类的静态字段
- JNI引用

按上图所示就很清晰的展现了这个过程，从根元素出发，一直遍历到尾端，所过之处标记为存活对象，这时候剩下的就是非存活对象了。

标记阶段一般都会触发全线暂停（STW，Stop The World），暂停阶段应用线程是不工作的。因为不进行这样的暂停，标记过程中对象引用关系还在不断变化，那就没有办法安全的工作。值得注意的是，暂停的时间和堆内存大小和对象总数是没有直接关系的，而是由存活对象的数量决定的，所以单方面的无脑加堆内存大小有时候并不能起到什么作用，甚至变得更慢（后面讲GC优化会详细叙述）。


### 删除不可达对象

其实这算是个宏观概念了，一般来说有三种实现手段：`复制`、`清除`、`整理`

#### 复制（标记-复制）

`标记-复制`就是移动存活的对象到另一个额外的空间，这样做有两点好处：

1. 边标记的时候就可以边复制了（因为用到了额外的空间）；
2. 删除不可达对象时就不需要遍历处理了，因为可达对象已经在另一块内存空间，这时候当前内存空间（无论可达还是不可达）直接清空就行。

该方式的缺点也显而易见，需要维护额外的空间。

![](http://img.yelizi.top/529b1968-bffb-48f1-98ec-9b976fb2dc8a.jpg$xyz)


#### 清除

`标记-清除`就很好理解了，直接遍历对象，不可达的直接删除，就这样。

![](http://img.yelizi.top/e0d9ce43-401c-4902-84cc-335c09853205.jpg$xyz)

如图所示，清除后，原本不可达对象占用的内存空间就被空闲出来了，因为区域是散乱的，所以就得额外维护一个空闲区域表来记录所有空闲区域以及空闲区域的大小。

当然仅仅是额外维护这么一个记录表，还是没什么问题的。该方式最大的问题是存不下大多数对象的碎片区域会越来越多，可能极端情况下，碎片区域加起来有明显的空闲内存，但就是分配不了对象了，这时就会OOM了。



#### 整理

针对`标记-清除`的优化就是`标记-清除-整理`，该算法在清除过后，会将存活对象移动到内存起始处依次放好，这样后面空出的就是一整块大的内存空间用来分配。

当然，这也带来了性能的损耗，这就是有得有失了。

![](http://img.yelizi.top/494e0bac-483c-4692-bb22-3a6fe62cd4d2.jpg$xyz)


## 引出分代假设

执行GC需要STW，很显然，对象越多完成一次回收的时间就越长，而STW阶段，程序是没有办法对外提供服务的，那是不可接受的。

当然这难不倒聪明的研究人员，经研究发现，程序中大多数可回收的内存可分为两类：

1. 大部分对象很快不再使用，生命周期短；
2. 还有一部分不会立即使用，但也不会持续太长时间。

这就形成了`弱代假设`，即可以根据对象的不同特点，把对象进行分类。基于该假设，内存就被分为`年轻代`和`老年代`，也就是常说的Young区和Old区。因为内存被划分了，不再是个整体每次一锅炖，这样就可以根据不同区域的特点，采用不同的算法来大幅度提高GC的性能。


## GC管理的堆内存划分

先提一点，一般来说只要基于分代假设的GC，内存池的划分都是类似的，可能具体算法实现不同，但宏观概念是一致，所以按该处理解即可。

![](http://img.yelizi.top/ba496885-9b68-40dd-8e30-8e04dee2a859.jpg$xyz)

### 年轻代（Young区）

#### 新生代（Eden区）

按直译就是`伊甸区`（搜搜伊甸园是啥就秒懂了），用来分配新创建的对象。通常会有多个线程同时创建多个对象，所以Eden区被划分为多个线程本地分配缓冲区（即TLAB）。通过这种缓冲区划分，大部分对象直接由JVM在对应线程的TLAB中分配，避免与其他线程的同步操作。

如果TLAB中没有足够的空间来进行分配，就会在共享Eden区分配。若是共享Eden区空间也不够，重点就来了，触发一次年轻代GC（即YGC）来释放内存空间，如果YGC后还是不够分配，那对象就会直接在老年代区进行分配（还不够？那就扯远了，等老年代再讲）。


#### 存活区（Survivor区）

一般存活区有俩，称为from区和to区，注意的是，始终有一个存活区是空的。怎么理解呢？from区存放每次YGC后存活的对象，下一次YGC后，Eden区存活的对象和from区一并复制到to区，结束后from区没有对象，to区存放新的所有的存活对象，这时候from区和to区身份互换，from变成to，to变成from。

![](http://img.yelizi.top/fad51206-51e2-4b8e-8f58-c32db96e007e.jpg$xyz)

按照这种设计，存活的对象会在两个存活区之间不停的复制，那么没有头吗？（那当然有头，不然要老年代区干啥），如果一个对象经历了这个过程多次还存活着，那我们就有理由相信它还能活的更久，这时候就会触发提升，说白了就是去老年代区。

这个触发提升的多次是个配置阈值，默认是15（也是HotSpot JVM允许的最大值），可以通过`-XX:+MaxTenuringThreshold`来指定。

当然对象提升也不是完全依照这个，若是存活区内存不够了，提升也可能会提早进行。


#### YGC理解

当年轻代进行GC时，将所有从root可达的对象过一遍（包括Eden区和Survivor From区），并标记为存活对象。

标记完成后，Eden区中所有存活对象将会被复制到存活区，然后Eden区就被清空，这种方式称为`标记-复制`。

**为啥是复制而不是移动的思考**：这里复制就是在存活区copy一份一样的就ok了，而移动其实可以看做是copy完后又删除了原本Eden区的对象，其实这步删除就是浪费性能的多余操作，因为Eden区在一次YGC后是要整个清空的，所以为啥是复制而不是移动。

### 老年代（Old区）

老年代里倒是没有细分小区域了，但这绝对不是其简单的表征，相反，老年代的处理才是复杂之处。

老年代一般来说内存空间更大，里面的对象是垃圾的概率更小，所以其发生GC的频率是要比年轻代小很多的（分代假设理论就是这样去优化性能的）。

一般来说，老年代的内存空间是更成熟也是承担责任更多的，所以为避免空间碎片浪费，老年代GC（即OGC）后，删除不可达对象后是要进行一次整理的，这种方式一般称为`标记-清除-整理`。步骤大概如下：

1. 标记所有通过GC roots可达的对象；
2. 删除所有不可达对象；
3. 复制所有存活对象，从老年代开始的地方依次存放。